# 프로그래머스 / 연속된 부분 수열의 합 (공통)
# 제출

def solution(sequence, k):
    # 누적합 리스트
    prefix = [0]
    cnt = 0
    # 인덱스 체크
    n = 0
    m = n + 1
    answer = [0, len(sequence)]
    # 수열의 누적합 리스트 생성
    for i in range(len(sequence)):
        cnt += sequence[i]
        prefix.append(cnt)

    # 누적합 리스트 인덱스를 벗어나지 않기
    while n < m and m < len(prefix):
        # 만약 누적합 인덱스 m의 수에서 인덱스 n의 수를 뺀 숫자가 k 이면
        if prefix[m] - prefix[n] == k:
            # 이전의 길이보다 길이가 짧으면
            if (m-1) - n < (answer[1] - answer[0]):
                # return 값 길이가 짧은 인덱스로 재설정
                answer = [n, m-1]
            # 그 다음 값을 확인하기 위해 m 인덱스 + 1
            m += 1
        # 만약 누적합 m인덱스 값 에서 n 인덱스 값을 뺀 값이 k 보다 작으면
        elif prefix[m] - prefix[n] < k:
            # 그 뒤의 인덱스 값을 더한 값으로 비교하기 위해 m 인덱스 + 1
            m += 1
        # m 인덱스 값 - n 인덱스 값이 k 보다 크면 n 인덱스 + 1
        else:
            n += 1
    return answer

#정확성  테스트
#테스트 1 〉	통과 (0.01ms, 10.4MB)
#테스트 2 〉	통과 (0.01ms, 10.2MB)
#테스트 3 〉	통과 (0.06ms, 10.3MB)
#테스트 4 〉	통과 (0.60ms, 10.1MB)
#테스트 5 〉	통과 (9.62ms, 10.7MB)
#테스트 6 〉	통과 (9.53ms, 11.6MB)
#테스트 7 〉	통과 (33.08ms, 13.4MB)
#테스트 8 〉	통과 (69.56ms, 17.3MB)
#테스트 9 〉	통과 (143.54ms, 24.5MB)
#테스트 10 〉	통과 (349.27ms, 47MB)
#테스트 11 〉	통과 (529.15ms, 85.2MB)
#테스트 12 〉	통과 (586.74ms, 85.2MB)
#테스트 13 〉	통과 (620.60ms, 85.2MB)
#테스트 14 〉	통과 (600.90ms, 85.3MB)
#테스트 15 〉	통과 (665.09ms, 85.4MB)
#테스트 16 〉	통과 (455.96ms, 91MB)
#테스트 17 〉	통과 (684.44ms, 91MB)
#테스트 18 〉	통과 (0.02ms, 10.1MB)
#테스트 19 〉	통과 (0.01ms, 10.2MB)
#테스트 20 〉	통과 (0.01ms, 10.3MB)
#테스트 21 〉	통과 (0.01ms, 10.1MB)
#테스트 22 〉	통과 (0.01ms, 10.2MB)
#테스트 23 〉	통과 (0.01ms, 10.3MB)
#테스트 24 〉	통과 (570.87ms, 56.4MB)
#테스트 25 〉	통과 (364.65ms, 56.2MB)
#테스트 26 〉	통과 (659.72ms, 56.3MB)
#테스트 27 〉	통과 (632.30ms, 56.3MB)
#테스트 28 〉	통과 (501.88ms, 56.2MB)
#테스트 29 〉	통과 (529.90ms, 56.4MB)
#테스트 30 〉	통과 (613.94ms, 91MB)
#테스트 31 〉	통과 (0.01ms, 10.2MB)
#테스트 32 〉	통과 (0.01ms, 10.2MB)
#테스트 33 〉	통과 (0.01ms, 10.1MB)
#테스트 34 〉	통과 (0.01ms, 10.2MB)